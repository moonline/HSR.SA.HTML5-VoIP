\chapter{Architektur}

\section{Architektur-Übersicht}
	Das folgende Diagramm zeigt eine Übersicht über die notwendigen Komponenten für eine Videoplattform mit JavaScript. Die Applikation ist als "`Fat-Client"'-Architektur aufgebaut. Es gibt keine Serverkomponenten für die Applikation selbst. Erst für den Verbindungsaufbau werden Vermittlungsserver benötigt.
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{../architekturanalayse/img/bigPicture.png}
		\caption{Big Picture JS VoIP App}
	\end{figure}
	
	Jeder Client besitzt Signaling Channels, die mit einem Signaling Server interagieren. Hier wurde als Beispiel eine Message Queue und ein SIP Server verwendet. Die Kommunikation läuft entsprechend über XHR oder SIP.
	
	Für das Media Handling und die P2P-Kommunikation greift jeder Client über den Browser auf die lokale Kamera und das lokale Mikrophon zu.
	
	Ein Verbindungsaufbau beginnt bei einem Client. Der Browser generiert eine Offer für den andern Client und sendet diese in einer Signaling Message über einen Signaling Server wie eine einfache Message Queue oder einen SIP Server an den andern Client. Der Browser des andern Clients generiert eine Answer und schickt diese auf dem gleichen Weg zurück. Anschliessend bauen die Clients die direkte P2P Connection auf. Sobald diese aufgebaut wurde, können Daten oder Video- und Audio gestreamt werden.
	
	Für den Abbau sendet ein Client ein bye. Anschliessend bauen beide Clients die P2P Connection ab.

\section{Architektur-Schichten}
	Der logische Aufbau der Software besteht aus vier Schichten:
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{../architekturanalayse/img/architecture.png}
		\caption{Architekturdiagramm JS VoIP App}
	\end{figure}
	Im untersten Layer sind Services und Libraries enthalten, auf die die oberen Layer zugreifen.
	Der Application Layer beinhaltet View Models für das User Interface und interagiert mit dem Model.
	

\begin{landscape}
\section{Domainmodel}
	Im folgenden Diagramm sind die wichtigsten konzeptionellen Klassen und ihre Beziehungen untereinander aufgeführt.
	\begin{figure}[H]
		\centering
		\includegraphics[width=1.2\textwidth]{../architekturanalayse/img/domain.png}
		%\caption{Strukturdiagramm JS VoIP App}
	\end{figure}
	Herzstück der Applikation sind die Channels und die Connection sowie das Contactbookmanagement.
	
	Die Channels laufen im Hintergrund und verbinden den User mit einem oder mehreren Signaling-Servern. Sie werden beim Login des Benutzers gestartet und müssen entsprechend ein Channel-Interface implementieren. So laufen z.B. ein SIP Channel und ein XHR Channel, ja nach dem was der Benutzer für Accounts besitzt.
	
	Die Connection übernimmt das komplette Handling der P2P-Verbindung inklusive Verbindungsauf- und -abbau. Sie greift über den Host auf die lokale Kamera zu und sendet und empfängt über einen Channel "`Offers"' und "`Answers/Replies"'.
	
	Die Kontaktverwaltung übernimmt der ContactbookManager. Er importiert Kontaktbücher anhand der Konfiguration von den Quelle "`Datei"', "`Ordner"' oder "`Online"'. Für die formatspezifischen Importprozesse sind die jeweiligen Kontaktbücher zuständig. Dazu müssen alle Kontaktbücher das Addressbook-Interface umsetzen.
\end{landscape}

\section{Connection}


\section{Adressbook}


\section{Interfaces}


\clearpage

\section{Architektur-Designmotivations}
	\subsection{Client/Server vs. reine Client-Applikation}
		\subsubsection{Vorteile Client/Server-Umsetzung}
		\begin{itemize}
			\item Schlanker Client
			\item Es wird nur eine Schnittstelle benötigt zwischen Client und Server, der gesamte Verkehr kann über HTTP abgewickelt werden.
			\item Nur der Server muss die Schnittstellen zu anderen Diensten
			unterstützen. Keine zusätzlichen Schnittstellen-Anforderungen an den Client.
			\item Es ist einfacher durch Firewalls durchzukommen, da die Kommunikation genau kontrolliert werden kann.
		\end{itemize}
		\subsubsection{Nachteile}
		\begin{itemize}
			\item Redundanzen, da Funktionalität zwischen Client und Server durch
			ein eigenes Protokoll abgebildet und damit auf beiden Seiten Teile derselben
			Funktionalität umgesetzt werden müssen.
			\item Ein Anwender ist an den Server oder die Serverimplementation gebunden.
			Die Applikation läuft nicht ohne den Server.
			\item Der Server ist ein "`Single Point of Failure"'.
			\item Sollen weitere Schnittstellen umgesetzt werden, so muss der Server
			erweitert werden, was aufwendiger ist, als den Client zu erweitern.
		\end{itemize}


		\subsubsection{Vorteile reine Client-Lösung}
		\begin{itemize}
			\item Es wird kein Server benötigt.
			\item Anwender können einen beliebigen Kommunikationsserver
			(beispielsweise SIP\footnote{Session Initiation Protocol \cite{IETF-SDP-RFC}} oder
			XMPP\footnote{Extensible Messaging and Presence Protocol}) für das
			Signaling verwenden und sogar selbst eine eigene Channelimplementation
			hinzufügen.
			\item Um die Applikation für weitere Schnittstellen zu erweitern sind keine
			Kenntnisse der Servertechnologie notwendig.
			\item Die Applikation ist insgesamt weniger aufwändig aufgebaut, da sie
			weniger Redundanzen beinhaltet.
			\item Es ist keine eigene SIP-/XMPP-Server-Implementation erforderlich
			(bereits vorhandene Serverinfrastrukturen werden genutzt).
		\end{itemize}
		\subsubsection{Nachteile}
		\begin{itemize}
			\item Die möglichen Schnittstellen sind auf die Browserfunktionalität
			begrenzt (HTTP, WebSockets, SDP, STUN, UserMedia). Dadurch
			muss ein SIP- oder XMPP-Provider WebSockets unterstützen, damit er für das
			Signaling genutzt werden kann.
			\item Der Client wird umfangreicher.
			\item Probleme mit Firewalls und Routern möglich, die WebSocket-Pakete nicht
			weiterleiten. WebSockets können grundsätzlich über einen beliebigen Port laufen, meist wird jedoch Port 80 verwendet.
			\item Performanceprobleme möglich, da sämtliche Logik, inklusive dem Parsen
			der verschiedenen Protokolle, vom Client abgearbeitet werden muss.
		\end{itemize}

		\subsubsection{Fazit}
			Aufgrund geringerer Abhängigkeiten und der Wahrscheinlichkeit, das die
			SIP-Server-Provider irgendwann WebSockets unterstützen, wird die Lösung
			"`reine Client Applikation"' gewählt.
			Für die Kommunikation mit Signalingservern, wie SIP oder XMPP, werden
			WebSockets eingesetzt, für das Signaling über XHR\footnote{XmlHTTPRequest}
			wird mit der Option "`Allow Cross Origin"' gearbeitet.

	\subsection{STUN-Service}
		STUN\footnote{Session Traversal Utilities for NAT \cite{IETF-STUN-RFC}}-Services sind zwingend
		notwendig, um die nach aussen sichtbare IP-Adresse des Clients herauszufinden.
		Neben der Möglichkeit, selbst einen STUN-Service aufzusetzen, gibt es frei
		verfügbare STUN-Services, beispielsweise von Mozilla oder Google.

		Für ein abgeschottetes Netz ist ein eigener STUN-Server zwingend notwendig.
		Für unseren Fall reichen die frei verfügbaren. Durch anpassen der
		Konfiguration ist es möglich, den Server festzulegen.

		Im Netz gibt es fertig konfigurierte virtuelle Maschinen mit einsatzbereitem
		STUN-Service\footnote{Mozilla, stun-vm \cite{Mozilla-STUN-VM}}.

	\subsection{SIP-Proxy vs. SIP-Server mit WebSockets}
		Unterstützt ein SIP-Server keine WebSockets, so kann ein SIP/WebSocket-Proxy
		dazwischen geschaltet werden. Die Konfiguration eines SIP-Proxies ist ähnlich
		aufwändig wie die Installation eines Kamailio
		\footnote{Kamailio SIP Server Project, \cite{Kamailio-Project}}-SIP-Servers, der in der neusten Version WebSockets unterstützt.

	\subsection{Sicherheit}
		WebRTC-Streams können nur verschlüsselt übertragen werden. Es gibt keine
		Möglichkeit, die Verschlüsselung abzuschalten. Dies führt zwar zu einem
		erhöhten Rechenbedarf auf dem Client, garantiert jedoch eine verschlüsselte
		Verbindung unabhängig von den Vorlieben des Entwicklers.
		Die Verschlüsselung erfolg über DTLS-SRTP\footnote{Datagram Transport Layer Security \cite{IETF-DTLS-RFC}} 
		keyings\footnote{Adam Roach, WebRTC: Security and Confidentiality \cite{AdamRoach-WebRTC-Security}}. 
		
		Die Verschlüsselung des Signaling-Channels ist abhängig von der eingesetzten
		Technologie. Werden z.B. Secure Websockets oder XHR über HTTPS eingesetzt so ist die Kommunikation verschlüsselt und nicht abgreifbar.
		
		Trotzdem kann ein Provider oder ein Geheimdienst Metadaten darüber sammeln, wer mit wem telefoniert.
		  
	\subsection{Hosting}
		Die JS-VoIP-App kann sowohl lokal, als auch von einem
		Webserver ausgeliefert ausgeführt werden. Es gibt keine speziellen Voraussetzungen. Ein Webserver ist daher nicht zwingend notwendig.
		

\clearpage
\section{Kommunikation}
	Die Kommunikation zwischen zwei Clients, einem STUN-Service und einem
	Signaling-Service wird im folgenden Diagramm dargestellt.
	\begin{figure}[H]
		\centering
		\includegraphics[width=\textwidth]{../architekturanalayse/img/callDiagramm.png}
		\label{img:deployment}
		\caption{Clientkommunikation}
	\end{figure}
	Die Clients beziehen vom STUN-Service ihre extern sichtbare IP und
	kommunizieren nach einem erfolgreichen Verbindungsaufbau direkt P2P ohne noch
	über den Signaling-Service zu gehen.
	
	Der Verbindungsabbau kann wahlweise über den Signaling-Server oder direkt P2P
	gesendet werden.
	
	
	\begin{landscape}		
		\begin{figure}[H]
			\centering
			\includegraphics[height=0.7\textwidth]{../architekturanalayse/img/connectionState.png}
			\label{img:deployment}
			\caption{Applikationszustände}
		\end{figure}
		Beim Verbindungsaufbau nimmt jeder Client entwerde die Rolle "`Caller"' oder
		"`Callee"' ein. Erlaubt der Benutzer Zugriff auf die Kamera, so wird die
		Verbindung aufgebaut und bleibt bestehen, bis einer der Clients die Verbindung mit einem "`bye"' beendet.
		
		Ungültige Messages werden ignoriert. "`bye"' führt in jedem Zustand zu einem
		Abbruch der Verbindung bzw. des Aufbaus, vorausgesetzt das "`bye"'
		kommt vom anderen Kommunikationspartner.
	\end{landscape}
	