\chapter{Infrastruktur}

\section{Hardware}
\begin{itemize}
	\setlength{\itemsep}{-\parsep}
	\item Persönliche Entwicklungsgeräte für jedes Teammitglied, bevorzugt Laptop (eigene Geräte)
	\item Zugewiesene Arbeitsplätze im Zimmer 1.258
	\item Mobile Devices mit WebRTC-fähigem Browser
	\item Virtual Server für Projektmanagement
	\item SIP Service (z. B. sipcall.ch), SIP-Server mit WebSockets-Support oder Webserver für XHR basierte Lösung
\end{itemize}

\section{Tools}
\subsection{Projektmanagement}
Das Projektmanagementtool Redmine bietet sich aus verschiedenen Gründen an:
\begin{itemize}
	\setlength{\itemsep}{-\parsep}
	\item Redmine ist bekannt vom SE2-Projekt.
	\item Redmine lässt sich auf den Virtual Servern der HSR leicht installieren.
	\item Redmine bietet den benötigten Funktionumfang und ist einfach zu bedienen.
	\item Redmine bietet Git-Repository-Integration, falls dies gewünscht ist.
\end{itemize}


\subsection{Versionsverwaltung}
\subsubsection{Git}
Git ist ein bewährtes Versionsverwaltungstool, bietet den Vorteil von lokalen Repositories, ist sehr schlank und bringt eine gute Merge-Automatik mit.

\subsubsection{GitHub}
Mit GitHub besitzen die Studenten durch andere Projekte bereits Erfahrung. Als
Studenten haben sie Zugriff auf kostenlose "`Private-Repositories"'. Zudem
bietet GitHub noch zusätzliche Funktionen wie Wiki, RST- und MD-Viewer sowie
Repository-Zugriff und Dateibearbeitung über ein Webinterface.

\subsubsection{Backup}
Ein zusätzliches Backup ist nicht notwendig, da durch die Versionierung mit Git die komplette Versionshistorie bei jedem Teilnehmer vorhanden ist. Somit ist das gesamte Projekt dreifach abgelegt (bei den Entwicklern sowie bei GitHub).


\subsection{Dokumentation}
\subsubsection{Für grosse Dokumentationen und Abgabedokumente: \LaTeX}
\LaTeX\ ist perfekt geeignet für grosse, gemeinsam zu erarbeitende Dokumente,
weil die Source-Dateien über Git versioniert und gemergt werden können und wenig
Platz verbrauchen. Zudem besteht ein sehr kleines Risiko auf Dokumentenverlust
bzw. Dokumentenfehler durch die Software, weil \LaTeX\ die Source-Dateien gar
nicht verändert, im Unterschied zu einer Office-Applikation.

\subsubsection{Für Notizen \& Meetingprotokolle: Restructured Text (rst), txt, Markdown (md)}
Für Notizen und kleine Dokumente reichen RST, TXT oder MD vollständig aus. Sie
sind schlank, bieten nur das notwendigste, können versioniert und gemergt
werden, weil es nur Textfiles sind, und werden von "`GitHub Document aPreview"'
unterstützt.

\subsubsection{Für Diagramme, Skizzen: LibreOffice Draw (OpenDocument)}
Wo es nicht anders geht, wird OpenDocument eingesetzt. Dabei wird
berücksichtigt, dass es über Git nicht inkrementell versioniert und nicht
gemerged werden kann.


\subsection{Modeling}
Als Modeling-Tool wird Astah gewählt, weil es das beste den Studenten
bekannte Tool ist.
Es deckt den geforderten Funktionsumfang grosszügig ab und bietet Image- sowie
PDF-Export.

\subsection{UI Drafting}
\begin{itemize}
	\setlength{\itemsep}{-\parsep}
	\item Evolus Pencil für UI Drafts
	\item eventuell LibreOffice Draw für UI Design Finals
\end{itemize}


\subsection{Frameworks}
\subsubsection{Adapter.js}
Adapter.js abstrahiert die verschiedenen Browserschnittstellen von WebRTC und vereinfacht die Entwicklung. Zudem muss bei einer Schnittstellenanpassung browserseitig nur der Adapter aktualisiert werden und nichts an der App geändert werden.

\subsubsection{Angular.js}
Angular.js ist ein bekanntes MVW- und Templating Framework, das eine saubere Trennung von Logik und Darstellung ermöglicht. Angular.js bindet darüber hinaus ViewModel Properties und Functions ans Template, wodurch sich Observerkonstrukte sparen lassen.

\subsubsection{Require.js}
Require.js soll zur Strukturierung und Autolading der Klassen und komponenten eingesetzt werden.

\subsubsection{LESS}
Less soll als clientseitiger CSS Parser eingesetzt werden, da es den CSS Code stark verschlankt und Vorteile wie Variablen und Mixins bietet.

\subsubsection{jQuery}
jQuery als eine der besten JavaScript-Bibliotheken, bietet sehr einfache
Elementselektoren und viele Funktionen, die das Entwickeln vereinfachen.


\subsection{Testing}
Testing Framework Anforderungen:
\begin{itemize}
	\setlength{\itemsep}{-\parsep}
	\item Testing mit realem Browser, Browsersimulationen unterstützen vermutlich WebRTC noch nicht
	\item Einfach einzubinden
	\item Einfach zu erweitern
	\item Bekannte Benutzung mit Tests und Asserts
	\item Möglichkeit zur Anbindung eines Build Tools
\end{itemize}

\subsubsection{JsUnit / QUnit}
JsUnit wie QUnit arbeiten mit einem realen Browser, sind einfach handzuhaben und bieten typische Assert-Syntax.



\subsection{Building}
Ein Build-Server wie Ant ist nicht nötig für dieses Projekt. JsUnit bietet zwar
eine Anbindungsmöglichkeit. Für unsern Anwendungsfall und die nicht sehr
komplexe Tool-Umgebung lohnt sich der Aufwand eines Build-Servers jedoch nicht.


\subsection{Entwicklungsumgebung}
Jeder Entwickler verwendet seine eigene bevorzugte Entwicklungsumgebung.


\subsection{RunTime Environment}
Als RunTime-Environment wird ein WebRTC kompatibler Browser (Firefox,
Chrome(ium)) benötigt.


